# This file was *autogenerated* from the file /Users/Olive/Documents/Projects/cat_stance/limb_model.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_180 = Integer(180); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_1en3 = RealNumber('1e-3'); _sage_const_8 = Integer(8); _sage_const_0p518223 = RealNumber('0.518223'); _sage_const_1p5en3 = RealNumber('1.5e-3'); _sage_const_1p68353 = RealNumber('1.68353'); _sage_const_1p77215 = RealNumber('1.77215'); _sage_const_2p5en3 = RealNumber('2.5e-3'); _sage_const_20 = Integer(20); _sage_const_0p8 = RealNumber('0.8'); _sage_const_2en3 = RealNumber('2e-3'); _sage_const_45 = Integer(45); _sage_const_0p453598 = RealNumber('0.453598'); _sage_const_1p57080 = RealNumber('1.57080'); _sage_const_1p062100 = RealNumber('1.062100'); _sage_const_0p5 = RealNumber('0.5'); _sage_const_3p5e5 = RealNumber('3.5e5'); _sage_const_0p601398 = RealNumber('0.601398'); _sage_const_1p43286 = RealNumber('1.43286'); _sage_const_1p87549 = RealNumber('1.87549'); _sage_const_0p700844 = RealNumber('0.700844'); _sage_const_0p813389 = RealNumber('0.813389'); _sage_const_12 = Integer(12); _sage_const_1p83641 = RealNumber('1.83641'); _sage_const_10 = Integer(10); _sage_const_15 = Integer(15); _sage_const_1p190800 = RealNumber('1.190800'); _sage_const_0p409172 = RealNumber('0.409172'); _sage_const_100 = Integer(100); _sage_const_0p386661 = RealNumber('0.386661'); _sage_const_1p26610 = RealNumber('1.26610'); _sage_const_1p06157 = RealNumber('1.06157'); _sage_const_0p389248 = RealNumber('0.389248')#
# model specific constants
#

# limb topology
_link_lengths = (_sage_const_0p8 , _sage_const_0p5 )
_joint_angles_reference = vector(RDF, [_sage_const_45 *pi/_sage_const_180 , pi/_sage_const_2 ])
_joint_angle_pairs = matrix(RDF, [[_sage_const_1p190800 , _sage_const_1p83641 ],
                                  [_sage_const_1p062100 , _sage_const_1p87549 ],
                                  [_sage_const_0p813389 , _sage_const_1p87549 ],
                                  [_sage_const_0p700844 , _sage_const_1p83641 ],
                                  [_sage_const_0p601398 , _sage_const_1p77215 ],
                                  [_sage_const_0p518223 , _sage_const_1p68353 ],
                                  [_sage_const_0p453598 , _sage_const_1p57080 ],
                                  [_sage_const_0p409172 , _sage_const_1p43286 ],
                                  [_sage_const_0p386661 , _sage_const_1p26610 ],
                                  [_sage_const_0p389248 , _sage_const_1p06157 ]])
# moment arms and tendon routings
_r_0 = -_sage_const_10 /_sage_const_100 
_r_1 = _sage_const_7 /_sage_const_100 
_r_2 = -_sage_const_8 /_sage_const_100 
_r_3 = _sage_const_12 /_sage_const_100 
_moment_arm_matrix =  matrix(RDF, [[_r_0, _r_0, _r_1, _r_1],
                                   [_r_2, _r_3, _r_2, _r_3]])

# muscle structure
_sigma_max = _sage_const_3p5e5 
_pcsa = vector(RDF, [_sage_const_1en3 , _sage_const_2en3 , _sage_const_1p5en3 , _sage_const_2p5en3 ])
_muscle_lengths = vector(RDF, [_sage_const_20 /_sage_const_100 , _sage_const_10 /_sage_const_100 , _sage_const_20 /_sage_const_100 , _sage_const_15 /_sage_const_100 ])


#
# symbolic computations for the endpoint functions
#
_L = var('L_0 L_1') # symbolic link lengths
_q = var('q_0 q_1') # symbolic joint angles

_symbolic_endpoint_position = matrix([[L_0 * cos(q_0) + L_1 * cos(q_0 + q_1)],
                                      [L_0 * sin(q_0) + L_1 * sin(q_0 + q_1)]])

_symbolic_endpoint_jacobian = jacobian(_symbolic_endpoint_position, (q_0, q_1))

def _numeric(expr, q, L = _link_lengths):
    return expr.subs(L_0 = L[_sage_const_0 ], L_1 = L[_sage_const_1 ],
                     q_0 = q[_sage_const_0 ], q_1 = q[_sage_const_1 ]).N()

def endpoint_position(joint_angles, link_lengths):
    return _numeric(_symbolic_endpoint_position, joint_angles, link_lengths)

def endpoint_jacobian(joint_angles, link_lengths):
    return _numeric(_symbolic_endpoint_jacobian, joint_angles, link_lengths)

def muscle_strain(joint_angles_difference, muscle_lengths = _muscle_lengths, moment_arm_matrix = _moment_arm_matrix):
    result = moment_arm_matrix.T * joint_angles_difference
    for i in range(len(result)):
        result[i] /= muscle_lengths[i]
    return result

def force_length_curve(muscle_strain, shape_factor=_sage_const_0p5 ):
    return muscle_strain.apply_map(lambda s: _sage_const_0  if s >= shape_factor else (_sage_const_1  - (s/shape_factor)**_sage_const_2 ))

def maximal_muscle_forces(muscle_strain, sigma_max = _sigma_max, pcsa = _pcsa):
    return diagonal_matrix(sigma_max * (force_length_curve(muscle_strain).pairwise_product(pcsa)))

def endpoint_force_matrix(joint_angles,
                          joint_angles_reference = _joint_angles_reference,
                          link_lengths = _link_lengths,
                          muscle_lengths = _muscle_lengths,
                          moment_arm_matrix = _moment_arm_matrix,
                          sigma_max = _sigma_max,
                          pcsa = _pcsa):
    joint_angles_difference = joint_angles_reference - joint_angles
    _muscle_strain = muscle_strain(joint_angles_difference, muscle_lengths, moment_arm_matrix)
    F_0 = maximal_muscle_forces(_muscle_strain, sigma_max, pcsa)
    _endpoint_jacobian = endpoint_jacobian(joint_angles, link_lengths)
    return _endpoint_jacobian.T.inverse() * moment_arm_matrix * F_0

def n_cube_alt_ieqs(n):
    """
    Construct the inequalities for the n-cube [0,1]^n in a format that
    the Polyhedron constructor accepts
    """
    e = identity_matrix(n)
    lt_one  = [[_sage_const_1 ] + (-e[i]).list() for i in xrange(n)]
    gt_zero = [[_sage_const_0 ] + (e[i]).list() for i in xrange(n)]
    return lt_one + gt_zero
    
def planar_upwards_force_activation_space(generators):
    """
    Construct the activation space corresponding to the output
    actions codirectional to the y-axis (second coordinate).
    
    The generators must be planar (i.e. a 2-by-n matrix).
    """
    d, n = generators.dimensions()
    
    if d != _sage_const_2 :
        raise ValueError('The generators must be two dimensional')

    ieqs_n_cube = n_cube_alt_ieqs(n)                    # activations in [0,1]^n
    ieqs_nonnegative_y = [[_sage_const_0 ] + generators[_sage_const_1 ,:].list()] # output y >= 0
    ieqs = ieqs_n_cube + ieqs_nonnegative_y
    eqns = [[_sage_const_0 ] + generators[_sage_const_0 ,:].list()]               # output x == 0
    return Polyhedron(ieqs=ieqs, eqns=eqns)

def projection_into_own_dimension(p):
    """
    Project a polytope containing the origin into a vector space of
    its own dimension. The result is a polyhedron isomorphic to the
    original.
    """
    
    dim = p.dim()
    ambient_face = p.faces(dim)[_sage_const_0 ]
    
    if zero_vector(p.base_ring(), p.ambient_dim()) not in p:
        raise ValueError("The input polytope not contain the origin ")
    
    ambient_basis = span((v.vector() for v in ambient_face.vertex_generator())).basis_matrix()
    ambient_orthogonal_basis = ambient_basis.gram_schmidt(orthonormal=False)[_sage_const_0 ] # orthonormality does not work over QQ
    return linear_transformation(ambient_orthogonal_basis.T)

def feasible_output_force_set(joint_angles):
    from zonotope import zonotope_from_vectors
    generators = endpoint_force_matrix(joint_angles)
    return zonotope_from_vectors(matrix(QQ,generators.T))

_all_generators = [endpoint_force_matrix(joint_angles) for joint_angles in _joint_angle_pairs]
_feasible_output_force_sets = [feasible_output_force_set(joint_angles) for joint_angles in _joint_angle_pairs]
_activation_spaces = [planar_upwards_force_activation_space(matrix(QQ,generators)) for generators in _all_generators]
_activation_spaces_projections = [p.projection()(projection_into_own_dimension(p)) for p in _activation_spaces]


